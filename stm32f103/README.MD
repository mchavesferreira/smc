

# Curso STM32f103


STM32F103 - PDF Documentation

https://www.st.com/en/microcontrollers-microprocessors/stm32f103/documentation.html


## Ambiente de Desenvolvimenoto


### Conhe√ßa o STM32: 
https://www.makerhero.com/blog/conheca-o-microcontrolador-stm32

https://embarcados.com.br/memoria-do-microcontrolador-stm32f103c8t6/

###  Como programar STM32 em C : https://www.makerhero.com/blog/como-programar-stm32-em-c/

STM32CubeMX
https://www.st.com/en/development-tools/stm32cubemx.html#get-software

STM32CubeProgrammer:
https://www.st.com/en/development-tools/stm32cubeprog.html


#  Biblioteca HAL no STM32

A **HAL (Hardware Abstraction Layer)** √© uma biblioteca desenvolvida pela **STMicroelectronics** para facilitar a programa√ß√£o de microcontroladores **STM32**. Ela oferece uma camada de abstra√ß√£o para os perif√©ricos do microcontrolador, permitindo que o desenvolvedor interaja com o hardware sem precisar manipular diretamente os registradores de baixo n√≠vel.

---

##  Caracter√≠sticas Principais

‚úî **Abstra√ß√£o de Hardware** ‚Üí C√≥digo mais port√°vel entre diferentes modelos da fam√≠lia STM32.  
‚úî **Facilidade de Uso** ‚Üí APIs de alto n√≠vel simplificam a configura√ß√£o de perif√©ricos.  
‚úî **Compatibilidade com CMSIS** ‚Üí A HAL funciona em conjunto com o **CMSIS** (Cortex Microcontroller Software Interface Standard).  
‚úî **Gera√ß√£o Autom√°tica com STM32CubeMX** ‚Üí O STM32CubeMX pode gerar c√≥digo baseado na HAL.  


-- 
## Instala√ß√£o 
STM32CubeMX
https://www.st.com/content/st_com/en/stm32cubemx.html


## Gravando com UART

Configurando o modo boot:

O Blue Pill tem dois jumpers chamados BOOT0 e BOOT1 (√†s vezes escrito como BOOT0 e BOOT1 no PCB).

Para programar via serial:

    BOOT0 ‚Üí 1 (High) (lado mais pr√≥ximo da borda).

    BOOT1 ‚Üí 0 (Low) (lado mais pr√≥ximo dos pinos).

Depois de gravar, para rodar o programa, volte para:

    BOOT0 ‚Üí 0

    BOOT1 ‚Üí 0

---

##  Estrutura da Biblioteca HAL

A HAL est√° dividida em diferentes camadas e m√≥dulos:

- **Camada de Driver**  
  - APIs para controle de perif√©ricos (exemplo: `HAL_GPIO_WritePin()` para configurar um GPIO).  
- **Camada de Middleware**  
  - Implementa√ß√£o de protocolos como **USB, TCP/IP, RTOS** e outros.  
- **Camada de Aplica√ß√£o**  
  - C√≥digo final da aplica√ß√£o que utiliza os drivers HAL.

---

##  Vantagens da HAL

‚úÖ **C√≥digo mais port√°vel** entre diferentes modelos STM32.  
‚úÖ **Facilidade na configura√ß√£o** dos perif√©ricos sem manipular registradores diretamente.  
‚úÖ **Compat√≠vel com middlewares** como FreeRTOS, USB e TCP/IP.  

---

## Desvantagens da HAL

‚ùå Pode ser **mais lenta** do que c√≥digo diretamente baseado em registradores.  
‚ùå Ocupa **mais espa√ßo na mem√≥ria** comparado √† biblioteca **LL (Low-Level)**.  

---



---
##  Exemplo de C√≥digo: Alternando um GPIO

O c√≥digo abaixo configura um pino GPIO como sa√≠da e faz seu estado alternar a cada 500ms.

```java

#include "stm32f1xx_hal.h" // Biblioteca HAL para STM32F1 (exemplo)

// Fun√ß√£o para inicializar o GPIO
void GPIO_Init(void) {
    __HAL_RCC_GPIOC_CLK_ENABLE();  // Habilita o clock do GPIOC

    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_13;  // Define o pino PC13
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  // Modo sa√≠da push-pull
    GPIO_InitStruct.Pull = GPIO_NOPULL;  // Sem resistores internos
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  // Velocidade baixa
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);  // Inicializa o GPIO
}

// Fun√ß√£o principal
int main(void) {
    HAL_Init();  // Inicializa a HAL
    GPIO_Init(); // Inicializa o GPIO

    while (1) {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);  // Alterna o pino PC13
        HAL_Delay(500);  // Aguarda 500ms
    }
}

```


##  Exemplo: Alternar um GPIO sem a HAL

Este c√≥digo alterna o pino PC13 (comum em placas como o STM32F103C8T6 "Blue Pill") sem usar a HAL, utilizando apenas manipula√ß√£o direta dos registradores.

```java

#include "stm32f10x.h"  // Defini√ß√µes espec√≠ficas do STM32F1 (ajuste conforme a fam√≠lia do STM32)

// Inicializa o GPIO manualmente
void GPIO_Init(void) {
    // Habilita o clock do GPIOC
    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;

    // Configura o PC13 como sa√≠da push-pull, velocidade de 2MHz
    GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);  // Limpa os bits de configura√ß√£o
    GPIOC->CRH |= (GPIO_CRH_MODE13_1); // Define como sa√≠da de 2MHz (10)
}

// Fun√ß√£o de atraso simples (n√£o precisa da HAL)
void delay_ms(uint32_t ms) {
    for (uint32_t i = 0; i < ms * 4000; i++) {
        __NOP(); // No Operation, apenas para gastar tempo
    }
}

// Fun√ß√£o principal
int main(void) {
    GPIO_Init(); // Inicializa o GPIO

    while (1) {
        GPIOC->ODR ^= (1 << 13);  // Alterna o estado do pino PC13
        delay_ms(500);  // Aguarda 500ms
    }
}

```



# üöÄ Aula: GPIO com STM32 HAL

## üìö Introdu√ß√£o

GPIO (General Purpose Input/Output) s√£o os pinos de prop√≥sito geral dos microcontroladores STM32, que podem ser configurados como **entrada**, **sa√≠da**, **entrada com pull-up/pull-down**, ou at√© para fun√ß√µes especiais como **interrup√ß√µes externas**.

A biblioteca **HAL** oferece uma camada de abstra√ß√£o para manipular esses pinos de forma simples e port√°vel.

---

## üîß Fun√ß√µes GPIO na Biblioteca HAL

### 1Ô∏è‚É£ **Configura√ß√£o dos GPIOs**

A configura√ß√£o dos pinos √© feita usando a fun√ß√£o:

```c
HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init);
```

* **Par√¢metros:**

  * `GPIOx`: Porta desejada (`GPIOA`, `GPIOB`, `GPIOC`, etc.).
  * `GPIO_Init`: Ponteiro para a estrutura que define os par√¢metros da configura√ß√£o.

* **Exemplo de estrutura de configura√ß√£o:**

```c
GPIO_InitTypeDef GPIO_InitStruct = {0};

GPIO_InitStruct.Pin = GPIO_PIN_13;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;

HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
```

---

### 2Ô∏è‚É£ **Escrever no GPIO (Sa√≠da)**

```c
HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
```

* **Par√¢metros:**

  * `GPIOx`: Porta (`GPIOA`, `GPIOB`...).
  * `GPIO_Pin`: Pino (`GPIO_PIN_13`...).
  * `PinState`: `GPIO_PIN_SET` (n√≠vel alto) ou `GPIO_PIN_RESET` (n√≠vel baixo).

* **Exemplo:**

```c
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
```

---

### 3Ô∏è‚É£ **Ler do GPIO (Entrada)**

```c
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
```

* **Retorna:** `GPIO_PIN_SET` ou `GPIO_PIN_RESET`.

* **Exemplo:**

```c
if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET) {
    // Bot√£o pressionado
}
```

---

### 4Ô∏è‚É£ **Alternar o estado do pino (Toggle)**

```c
HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
```

* **Exemplo:**

```c
HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
```

> üìù *Muito √∫til para piscar LEDs sem precisar saber se estava ligado ou desligado antes.*

---

### 5Ô∏è‚É£ **Desinicializar um GPIO (Liberar recursos)**

```c
HAL_GPIO_DeInit(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin);
```

* **Exemplo:**

```c
HAL_GPIO_DeInit(GPIOC, GPIO_PIN_13);
```

---

## üèóÔ∏è Estrutura da configura√ß√£o (`GPIO_InitTypeDef`)

| Campo   | Descri√ß√£o                                             |
| ------- | ----------------------------------------------------- |
| `Pin`   | Qual pino ser√° usado (`GPIO_PIN_0` at√© `GPIO_PIN_15`) |
| `Mode`  | Modo do pino: sa√≠da, entrada, interrup√ß√£o, etc.       |
| `Pull`  | Pull-up, Pull-down, ou sem pull                       |
| `Speed` | Velocidade de opera√ß√£o (para sa√≠da)                   |

---

## üî• Modos poss√≠veis (`Mode`)

* `GPIO_MODE_INPUT` ‚Äî Entrada digital
* `GPIO_MODE_OUTPUT_PP` ‚Äî Sa√≠da push-pull
* `GPIO_MODE_OUTPUT_OD` ‚Äî Sa√≠da open-drain
* `GPIO_MODE_AF_PP` ‚Äî Fun√ß√£o alternativa push-pull
* `GPIO_MODE_AF_OD` ‚Äî Fun√ß√£o alternativa open-drain
* `GPIO_MODE_ANALOG` ‚Äî Modo anal√≥gico
* `GPIO_MODE_IT_RISING` ‚Äî Interrup√ß√£o borda de subida
* `GPIO_MODE_IT_FALLING` ‚Äî Interrup√ß√£o borda de descida
* `GPIO_MODE_IT_RISING_FALLING` ‚Äî Interrup√ß√£o em ambas bordas

---

## üéõÔ∏è Pull-up / Pull-down (`Pull`)

* `GPIO_NOPULL`
* `GPIO_PULLUP`
* `GPIO_PULLDOWN`

---

## ‚ö° Velocidade (`Speed`)

* `GPIO_SPEED_FREQ_LOW`
* `GPIO_SPEED_FREQ_MEDIUM`
* `GPIO_SPEED_FREQ_HIGH`
* `GPIO_SPEED_FREQ_VERY_HIGH`

---

## üí° Exemplo completo: Piscar LED

```c
GPIO_InitTypeDef GPIO_InitStruct = {0};

// 1. Habilita clock da porta GPIOC
__HAL_RCC_GPIOC_CLK_ENABLE();

// 2. Configura pino PC13 como sa√≠da
GPIO_InitStruct.Pin = GPIO_PIN_13;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

// 3. Loop infinito piscando LED
while (1) {
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
    HAL_Delay(500); // atraso de 500ms
}
```

---



##  Refer√™ncias Oficiais

üîπ Documenta√ß√£o oficial da ST: [HAL and LL Drivers](https://www.st.com/content/st_com/en/products/embedded-software/mcu-middleware/stm32-hal-library.html)  
üîπ Reposit√≥rio STM32Cube no GitHub: [STMicroelectronics/STM32Cube](https://github.com/STMicroelectronics)  
üîπ Documenta√ß√£o CMSIS (ARM): [CMSIS Overview](https://developer.arm.com/tools-and-software/embedded/cmsis)  
