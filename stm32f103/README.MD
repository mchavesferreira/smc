

# Curso STM32f103


STM32F103 - PDF Documentation

https://www.st.com/en/microcontrollers-microprocessors/stm32f103/documentation.html


## Ambiente de Desenvolvimenoto


### Conhe√ßa o STM32: 
https://www.makerhero.com/blog/conheca-o-microcontrolador-stm32

https://embarcados.com.br/memoria-do-microcontrolador-stm32f103c8t6/

###  Como programar STM32 em C : https://www.makerhero.com/blog/como-programar-stm32-em-c/

STM32CubeMX
https://www.st.com/en/development-tools/stm32cubemx.html#get-software

STM32CubeProgrammer:
https://www.st.com/en/development-tools/stm32cubeprog.html


#  Biblioteca HAL no STM32

A **HAL (Hardware Abstraction Layer)** √© uma biblioteca desenvolvida pela **STMicroelectronics** para facilitar a programa√ß√£o de microcontroladores **STM32**. Ela oferece uma camada de abstra√ß√£o para os perif√©ricos do microcontrolador, permitindo que o desenvolvedor interaja com o hardware sem precisar manipular diretamente os registradores de baixo n√≠vel.

---

##  Caracter√≠sticas Principais

‚úî **Abstra√ß√£o de Hardware** ‚Üí C√≥digo mais port√°vel entre diferentes modelos da fam√≠lia STM32.  
‚úî **Facilidade de Uso** ‚Üí APIs de alto n√≠vel simplificam a configura√ß√£o de perif√©ricos.  
‚úî **Compatibilidade com CMSIS** ‚Üí A HAL funciona em conjunto com o **CMSIS** (Cortex Microcontroller Software Interface Standard).  
‚úî **Gera√ß√£o Autom√°tica com STM32CubeMX** ‚Üí O STM32CubeMX pode gerar c√≥digo baseado na HAL.  


-- 
## Instala√ß√£o 
STM32CubeMX
https://www.st.com/content/st_com/en/stm32cubemx.html



---

##  Estrutura da Biblioteca HAL

A HAL est√° dividida em diferentes camadas e m√≥dulos:

- **Camada de Driver**  
  - APIs para controle de perif√©ricos (exemplo: `HAL_GPIO_WritePin()` para configurar um GPIO).  
- **Camada de Middleware**  
  - Implementa√ß√£o de protocolos como **USB, TCP/IP, RTOS** e outros.  
- **Camada de Aplica√ß√£o**  
  - C√≥digo final da aplica√ß√£o que utiliza os drivers HAL.

---

##  Vantagens da HAL

‚úÖ **C√≥digo mais port√°vel** entre diferentes modelos STM32.  
‚úÖ **Facilidade na configura√ß√£o** dos perif√©ricos sem manipular registradores diretamente.  
‚úÖ **Compat√≠vel com middlewares** como FreeRTOS, USB e TCP/IP.  

---

## Desvantagens da HAL

‚ùå Pode ser **mais lenta** do que c√≥digo diretamente baseado em registradores.  
‚ùå Ocupa **mais espa√ßo na mem√≥ria** comparado √† biblioteca **LL (Low-Level)**.  

---



---
##  Exemplo de C√≥digo: Alternando um GPIO

O c√≥digo abaixo configura um pino GPIO como sa√≠da e faz seu estado alternar a cada 500ms.

```java

#include "stm32f1xx_hal.h" // Biblioteca HAL para STM32F1 (exemplo)

// Fun√ß√£o para inicializar o GPIO
void GPIO_Init(void) {
    __HAL_RCC_GPIOC_CLK_ENABLE();  // Habilita o clock do GPIOC

    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_13;  // Define o pino PC13
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  // Modo sa√≠da push-pull
    GPIO_InitStruct.Pull = GPIO_NOPULL;  // Sem resistores internos
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  // Velocidade baixa
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);  // Inicializa o GPIO
}

// Fun√ß√£o principal
int main(void) {
    HAL_Init();  // Inicializa a HAL
    GPIO_Init(); // Inicializa o GPIO

    while (1) {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);  // Alterna o pino PC13
        HAL_Delay(500);  // Aguarda 500ms
    }
}

```


##  Exemplo: Alternar um GPIO sem a HAL

Este c√≥digo alterna o pino PC13 (comum em placas como o STM32F103C8T6 "Blue Pill") sem usar a HAL, utilizando apenas manipula√ß√£o direta dos registradores.

```java

#include "stm32f10x.h"  // Defini√ß√µes espec√≠ficas do STM32F1 (ajuste conforme a fam√≠lia do STM32)

// Inicializa o GPIO manualmente
void GPIO_Init(void) {
    // Habilita o clock do GPIOC
    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;

    // Configura o PC13 como sa√≠da push-pull, velocidade de 2MHz
    GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);  // Limpa os bits de configura√ß√£o
    GPIOC->CRH |= (GPIO_CRH_MODE13_1); // Define como sa√≠da de 2MHz (10)
}

// Fun√ß√£o de atraso simples (n√£o precisa da HAL)
void delay_ms(uint32_t ms) {
    for (uint32_t i = 0; i < ms * 4000; i++) {
        __NOP(); // No Operation, apenas para gastar tempo
    }
}

// Fun√ß√£o principal
int main(void) {
    GPIO_Init(); // Inicializa o GPIO

    while (1) {
        GPIOC->ODR ^= (1 << 13);  // Alterna o estado do pino PC13
        delay_ms(500);  // Aguarda 500ms
    }
}

```


##  Refer√™ncias Oficiais

üîπ Documenta√ß√£o oficial da ST: [HAL and LL Drivers](https://www.st.com/content/st_com/en/products/embedded-software/mcu-middleware/stm32-hal-library.html)  
üîπ Reposit√≥rio STM32Cube no GitHub: [STMicroelectronics/STM32Cube](https://github.com/STMicroelectronics)  
üîπ Documenta√ß√£o CMSIS (ARM): [CMSIS Overview](https://developer.arm.com/tools-and-software/embedded/cmsis)  
